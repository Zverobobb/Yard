#include "freeglut.h"
#include <math.h>
#include <iostream>
#include <thread>
#include <barrier>

#pragma region Константы

const int height = 1000;                        // Высота окна, пиксель
const int width = 1000;                         // Ширина окна, пиксель

const double PI = 3.14159265;                   // Число Пи
const double e = 2.718281828;                   // Число е
const double G = 6.6743015 * pow(10, -11);      // Гравитационная постоянная, м3/(кг*с2)

const double Mv = 28.98;                        // Молярная масса воздуха, г/моль
const double R = 8.314;                         // Универсальная газовая постоянная, Дж/(моль/К)
const double Pvm = 101325;                      // Давление воздуха на уровне моря, Па
const double Na = 6.02214076 * pow(10, 23);     // Число Авогадро, 1/моль

const double Kt = 4.184 * pow(10, 12);          // Энергия одной килотонны, Дж

const double rS = 7770;                         // Плотность Стали 301, кг/м3
const double rW = 19250;                        // Плотность Вольфрама, кг/м3
const double rPu = 19840;                       // Плотность Плутония-239, кг/м3
const double MaPu = 0.23905216342;              // Атомная масса Плутония-239, кг/моль
const double EdPu = 210.3;                      // Энергия деления одного автома Плутония-239, МэВ
const double MeV = 1.6 * pow(10, -13);          // Энергия одного электронвольта, Дж

const double EmPu = EdPu * MeV * Na / MaPu;     // Энергия деления одного кг Плутония-239, Дж/кг
const double MPu = 0.15 * Kt / EmPu;            // Требуемая масса Плутония-239 для взрыва нужной мощности, кг
const double Epol = MPu * EmPu * 0.01 / 100;    // Полезная энергия деления требуемой массы Плутония-239 (0.01% гамма-излучение), Дж

const double Mzar = 700;                        // Масса одного ядерного заряда, кг
const double MWol = 150;                        // Масса Вольфрама в одном ядерном заряде, кг
const double EWol = MWol * Epol;                // Энергия Волфрама после взрыва, Дж

int Kzar = 500;                              // Количество зарядов, шт

const double Tvm[2][29] = {                     // Температура воздуха в зависимости от высоты, К
    {   0,    500,  1000,  1500,  2000,  2500,  3000,  4000,  5000,  6000,  7000,  8000,  9000,  10000, 11000, 12000, 14000, 16000, 18000, 20000, 24000, 28000, 32000, 36000, 40000, 50000, 60000, 80000, 100000 }, // Высота, м
    { 288.2, 284.9, 281.7, 278.4, 275.2, 271.9, 268.7, 262.2, 255.7, 249.2, 242.7, 236.2, 229.7, 223.3, 216.8, 216.7, 216.7, 216.7, 216.7, 216.7, 220.6, 224.5, 228.5, 239.3, 250.4, 270.7,  247,  198.6,  196.6 }  // Температура на соответствующей высоте, К
};

const double  rvm = Pvm * Mv / R / Tvm[1][0];   // Плотность воздуха на уровне моря, кг/м3

#pragma endregion

#pragma region Классы

// Класс ступеней РН
class Stage {
public:
    double Ms;          // Сухая масса ступени, кг
    double M;           // Полная масса ступени, кг
    double Mt = Ms - M; // Масса топлива ступени, кг

    double Tm;          // Тяга ступени на уровне моря, кН
    double Tp;          // Тяга ступени в пустоте, кН

    double Im;          // Удельный импульс ступени на уровне моря, м/с
    double Ip;          // Удельный импульс ступени в пустоте, м/с
};

// Класс планет, спутников и Солнца
class Object {
public:
    double M;       // Масса объекта, кг
    double R;       // Радиус объекта, м

    double Rp;      // Перигелий орбиты, м
    double Ra;      // Афелий орбиты, м

    double C[2];    // Координаты объекта, м
    double V[2];    // Проекции скорости объекта, м/с
    double A[2];    // Проекции ускорения объекта, м/с2

    double g[11];   // 0 - Местное ускорение свободного падения от Солнца, м/с2
                    // 1 - Местное ускорение свободного падения от Меркурия, м/с2
                    // 2 - Местное ускорение свободного падения от Венеры, м/с2
                    // 3 - Местное ускорение свободного падения от Земли, м/с2
                    // 4 - Местное ускорение свободного падения от Марса, м/с2
                    // 5 - Местное ускорение свободного падения от Юпитера, м/с2
                    // 6 - Местное ускорение свободного падения от Сатурна, м/с2
                    // 7 - Местное ускорение свободного падения от Урана, м/с2
                    // 8 - Местное ускорение свободного падения от Нептуна, м/с2
                    // 9 - Местное ускорение свободного падения от Луны, м/с2
                    // 10 - Свободное место памяти, чтобы его обнулять при расчёте текущей орбиты РН (связано с излишней универсальностью некоторых методов)

    double phi[11]; // 0 - Угол относительно Солнца, рад
                    // 1 - Угол относительно Меркурия, рад
                    // 2 - Угол относительно Венеры, рад
                    // 3 - Угол относительно Земли, рад
                    // 4 - Угол относительно Марса, рад
                    // 5 - Угол относительно Юпитера, рад
                    // 6 - Угол относительно Сатурна, рад
                    // 7 - Угол относительно Ураная, рад
                    // 8 - Угол относительно Нептуна, рад
                    // 9 - Угол относительно Луны, рад
                    // 10 - Аналогично g
};

#pragma endregion

#pragma region Исходные данные

#pragma region Ступени РН

Stage One = {
             One.Ms = 15136,            // Сухая масса первой ступени, кг
             One.M = 177562,            // Полная масса первой ступени, кг
             One.Mt = One.M - One.Ms,   // Масса топлива первой ступени, кг

             One.Tm = 3354,             // Тяга первой ступени на уровне моря, кН
             One.Tp = 4085.2,           // Тяга первой ступени в пустоте, кН

             One.Im = 2582.973,         // Удельный импульс первой ступени на уровне моря, м/с
             One.Ip = 3141.162          // Удельный импульс первой ступени в пустоте, м/с
};

Stage Two = {
             Two.Ms = 6545,             // Сухая масса второй ступени, кг
             Two.M = 99765,             // Полная масса второй ступени, кг
             Two.Mt = Two.M - Two.Ms,   // Масса топлива второй ступени, кг

             Two.Tm = 792.5,            // Тяга второй ступени на уровне моря, кН
             Two.Tp = 990.2,            // Тяга второй ступени в пустоте, кН

             Two.Im = 2528.037,         // Удельный импульс второй ступени на уровне моря, м/с
             Two.Ip = 3145.086          // Удельный импульс второй ступени в пустоте, м/с
};

Stage Three = {
               Three.Ms = 2355,                   // Сухая масса третьей ступени, кг
               Three.M = 27755,                   // Полная масса третьей ступени, кг
               Three.Mt = Three.M - Three.Ms,     // Масса топлива третьей ступени, кг

               Three.Tp = 294.3,                  // Тяга третьей ступени на уровне моря, кН
               Three.Tm = Three.Tp,               // Тяга третьей ступени в пустоте, кН

               Three.Ip = 3521.79,                // Удельный импульс третьей ступени на уровне моря, м/с
               Three.Im = Three.Ip                // Удельный импульс третьей ступени в пустоте, м/с
};

Stage Rb = {
            Rb.Ms = 887,           // Сухая масса разгонного блока, кг
            Rb.M = 6280,           // Полная масса разгонного блока, кг
            Rb.Mt = Rb.M - Rb.Ms,  // Масса топлива разгонного блока, кг

            Rb.Tp = 19.9,          // Тяга разгонного блока на уровне моря, кН
            Rb.Tm = Rb.Tp,         // Тяга разгонного блока в пустоте, кН

            Rb.Ip = 3268.692,      // Удельный импульс разгонного блока на уровне моря, м/с
            Rb.Im = Rb.Ip          // Удельный импульс разгонного блока в пустоте, м/с
};

Stage A = {
           A.Ms = 605,            // Сухая масса аппарата, кг
           A.M = 1605,            // Полная масса аппарата, кг
           A.Mt = A.M - A.Ms,     // Масса топлива аппарата, кг

           A.Tm = 0.5884,         // Тяга аппарата на уровне моря, кН
           A.Tp = 4.7072,         // Тяга аппарата в пустоте, кН

           A.Ip = 3103.457,       // Удельный импульс аппарата на уровне моря, м/с
           A.Im = A.Ip            // Удельный импульс аппарата в пустоте, м/с
};

#pragma endregion

#pragma region Солнце, планеты, Луна и РН

Object Sun = {
              Sun.M = 1.9885 * pow(10, 30),     // Масса Солнца, кг
              Sun.R = 6.9551 * pow(10, 8),      // Радиус Солнца, м

              0,                                // Зануляются перигелий и афелий, которых у Солнца нет
              0,                                //

              Sun.C[0] = 0,                     // Координата Х Солнца, м
              Sun.C[1] = 0,                     // Координата Y Солнца, м
};

Object Earth = {
                Earth.M = 5.9726 * pow(10, 24),       // Масса Земли, кг
                Earth.R = 6.371 * pow(10, 6),         // Радиус Земли, м

                Earth.Rp = 1.4709829 * pow(10, 11),   // Перигелий орбиты Земли, м
                Earth.Ra = 1.52098232 * pow(10, 11),  // Афелий орбиты Земли, м

                Earth.C[0] = Sun.C[0],                // Координата Х Земли, м
                Earth.C[1] = Sun.C[1] + Earth.Rp,     // Координата Y Земли, м

                Earth.V[0] = 2.9783 * pow(10, 4),     // Проекция скорости Земли на ось Х, м/с
                Earth.V[1] = 0                        // Проекция скорости Земли на ось Y, м/с
};

Object Rocket = {
                 Rocket.M = One.M + Two.M + Three.M + Rb.M + A.M,   // Масса РН, кг

                 0,                                                 // Зануляется радиус, которого у РН нет
                 0,                                                 // Зануляются перигелий и афелий, которых у РН изначально нет
                 0,                                                 //

                 Rocket.C[0] = Earth.C[0],                          // Координата Х РН, м
                 Rocket.C[1] = Earth.C[1] + Earth.R,                // Координата Y РН, м

                 Rocket.V[0] = Earth.V[0] + 286.487,                // Проекция скорости РН на ось Х, м/с ("+" -  скорость вращения Земли на широте пуска)
                 Rocket.V[1] = Earth.V[1]                           // Проекция скорости РН на ось Y, м/с
};

Object RocketYa = {
                 RocketYa.M = 2 * pow(10, 6) + Mzar * Kzar,          // Масса РН с ЯРД (сухая масса + количество зарядов), кг

                 0,                                                 // Зануляется радиус, которого у РН нет
                 0,                                                 // Зануляются перигелий и афелий, которых у РН изначально нет
                 0,                                                 //

                 Rocket.C[0] = Earth.C[0],                          // Координата Х РН, м
                 Rocket.C[1] = Earth.C[1] + Earth.R,                // Координата Y РН, м

                 Rocket.V[0] = Earth.V[0] + 286.487,                // Проекция скорости РН на ось Х, м/с ("+" -  скорость вращения Земли на широте пуска)
                 Rocket.V[1] = Earth.V[1]                           // Проекция скорости РН на ось Y, м/с
};

Object Luna = {
               Luna.M = 7.3477 * pow(10, 22),               // Масса Луны, кг
               Luna.R = 1.7971 * pow(10, 6),                // Радиус Луны, м

               Luna.Rp = 3.63104 * pow(10, 8),              // Перигелий орбиты Луны, м
               Luna.Ra = 4.05696 * pow(10, 8),              // Афелий орбиты Луны, м

               Luna.C[0] = Earth.C[0],                      // Координата Х Луны, м
               Luna.C[1] = Earth.C[1] + Luna.Rp,            // Кооридната Y Луны, м

               Luna.V[0] = Earth.V[0] + 1.023 * pow(10, 3), // Проекция скорости Луны на ось Х, м/с
               Luna.V[1] = Earth.V[1]                       // Проекция скорости Луны на ось Y, м/с
};

Object Mercury = {
                  Mercury.M = 3.33022 * pow(10, 23),        // Масса Меркурия, кг
                  Mercury.R = 2.4397 * pow(10, 6),          // Радиус Меркурия, м

                  Mercury.Rp = 4.6001009 * pow(10, 10),     // Перигелий орбиты Меркурия, м
                  Mercury.Ra = 6.9817445 * pow(10, 10),     // Афелий орбиты Меркурия, м

                  Mercury.C[0] = Sun.C[0],                  // Координата Х Меркурия, м
                  Mercury.C[1] = Sun.C[1] + Mercury.Rp,     // Координата Y Меркурия, м

                  Mercury.V[0] = 4.736 * pow(10, 4),        // Проекция скорости Меркурия на ось Х, м/с
                  Mercury.V[1] = 0                          // Проекция скорости Меркурия на ось Y, м/с
};

Object Venus = {
                Venus.M = 4.8675 * pow(10, 24),         // Масса Венеры, кг
                Venus.R = 6.0518 * pow(10, 6),          // Радиус Венеры, м

                Venus.Rp = 1.07476259 * pow(10, 11),    // Перигелий орбиты Венеры, м
                Venus.Ra = 1.08942109 * pow(10, 11),    // Афелий орбиты Венеры, м

                Venus.C[0] = Sun.C[0],                  // Координата Х Венеры, м
                Venus.C[1] = Sun.C[1] + Venus.Rp,       // Координата Y Венеры, м

                Venus.V[0] = 3.502 * pow(10, 4),        // Проекция скорости Венеры на ось Х, м/с
                Venus.V[1] = 0                          // Проекция скорости Венеры на ось Y, м/с
};

Object Mars = {
               Mars.M = 6.4171 * pow(10, 23),       // Масса Марса, кг
               Mars.R = 3.3895 * pow(10, 6),        // Радиус Марса, м

               Mars.Rp = 2.06655 * pow(10, 11),     // Перигелий орбиты Марса, м
               Mars.Ra = 2.49232 * pow(10, 11),     // Афелий орбиты Марса, м

               Mars.C[0] = Sun.C[0],                // Координата Х Марса, м
               Mars.C[1] = Sun.C[1] + Mars.Rp,      // Координата Y Марса, м

               Mars.V[0] = 2.4077 * pow(10, 4),     // Проекция скорости Марса на ось Х, м/с
               Mars.V[1] = 0                        // Проекция скорости Марса на ось Y, м/с
};

Object Jupiter = {
                  Jupiter.M = 1.8986 * pow(10, 27),         // Масса Юпитера, кг
                  Jupiter.R = 6.9911 * pow(10, 7),          // Радиус Юпитера, м

                  Jupiter.Rp = 7.405736 * pow(10, 11),      // Перигелий орбиты Юпитера, м
                  Jupiter.Ra = 8.165208 * pow(10, 11),      // Афелий орбиты Юпитера, м

                  Jupiter.C[0] = Sun.C[0],                  // Координата Х Юпитера, м
                  Jupiter.C[1] = Sun.C[1] + Jupiter.Rp,     // Координата Y Юпитера, м

                  Jupiter.V[0] = 1.307 * pow(10, 4),        // Проекция скорости Юпитера на ось Х, м/с
                  Jupiter.V[1] = 0                          // Проекция скорости Юпитера на ось Y, м/с
};

Object Saturn = {
                 Saturn.M = 5.6846 * pow(10, 26),           // Масса Сатурна, кг
                 Saturn.R = 5.8232 * pow(10, 7),            // Радиус Сатурна, м

                 Saturn.Rp = 1.353572956 * pow(10, 12),     // Перигелий орбиты Сатурна, м
                 Saturn.Ra = 1.513325783 * pow(10, 12),     // Афелий орбиты Сатурна, м

                 Saturn.C[0] = Sun.C[0],                    // Координата Х Сатурна, м
                 Saturn.C[1] = Sun.C[1] + Saturn.Rp,        // Координата Y Сатурна, м

                 Saturn.V[0] = 9.69 * pow(10, 3),           // Проекция скорости Сатурна на ось Х, м/с
                 Saturn.V[1] = 0                            // Проекция скорости Сатурна на ось Y, м/с
};

Object Uran = {
               Uran.M = 8.6813 * pow(10, 25),           // Масса Урана, кг
               Uran.R = 2.5362 * pow(10, 7),            // Радиус Урана, м

               Uran.Rp = 2.748938461 * pow(10, 12),     // Перигелий орбиты Урана, м
               Uran.Ra = 3.004419704 * pow(10, 12),     // Афелий орбиты Урана, м

               Uran.C[0] = Sun.C[0],                    // Координата Х Урана, м
               Uran.C[1] = Sun.C[1] + Uran.Rp,          // Координата Y Урана, м

               Uran.V[0] = 6.81 * pow(10, 3),           // Проекция скорости Урана на ось Х, м/с
               Uran.V[1] = 0                            // Проекция скорости Урана на ось Y, м/с
};

Object Neptune = {
                  Neptune.M = 1.0243 * pow(10, 26),         // Масса Нептуна, кг
                  Neptune.R = 2.4622 * pow(10, 7),          // Радиус Нептуна, м

                  Neptune.Rp = 4.452940833 * pow(10, 12),   // Перигелий орбиты Нептуна, м
                  Neptune.Ra = 4.55394649 * pow(10, 12),    // Афелий орбиты Нептуна, м

                  Neptune.C[0] = Sun.C[0],                  // Координата Х Нептуна, м
                  Neptune.C[1] = Sun.C[1] + Neptune.Rp,     // Координата Y Нептуна, м

                  Neptune.V[0] = 5.4349 * pow(10, 3),       // Проекция скорости Нептуна на ось Х, м/с
                  Neptune.V[1] = 0                          // Проекция скорости Нептуна на ось Y, м/с
};

#pragma endregion

#pragma endregion

#pragma region Данные для расчётов 

std::barrier bar1(10), bar2(10);    // Инициализация барьеров для синхронизации потоков (10 - количество обрабатываемых потоков)

int orb;                            // Переменная для определения перелётной траектории

double Tmm = One.Tm;                // Тяга двигателей на уровне моря в момент времени 0, кН
double Tpp = One.Tp;                // Тяга двигателей в пустоте в момент времени 0, кН
double Ts;                          // Полная тяга двигателей на текущем расстоянии от Земли, кН

double Imm = One.Im;                // Удельный импульс двигателей на уровне моря в момент времени 0, м/с
double Ipp = One.Ip;                // Удельный импульс двигателей в пустоте в момент времени 0, м/с
double Is;                          // Полная удельная тяга на текущем расстоянии от Земли, м/с

double Mtt = One.Mt;                // Масса топлива ступени в момент времени 0, кг
double Ad;                          // Ускорение РН от двигателей, м/с2
double Vd;                          // Скорость РН от двигателей ЯРД, м/с
bool dvig = 1;                      // Факт работы двигателей РН

int s = 0;                          // Счётчик отработанных ступеней
double alpha;                       // Отклонение вектора тяги двигателей относительно главной нормали, рад

double Pv;                          // Давление воздуха на текущей высоте, Па
double rv;                          // Плотность воздуха на текущей высоте, кг/м3
double varTvm;                      // Температура воздуха на текущей высоте, К

double T = 0;                       // Счётчик времени, с
double dt = 0.01;                   // Шаг времени, с (значение "0" означает, что симуляция на "паузе")
double Start_time = -2;             // Время, для определения, когда надо сбрасывать новый заряд, с 

double Vg;                          // Значение импульса, необходимого РН в определённые моменты полёта, м/с
double dV = 0;                      // Переменная для расчёта изменений импульсов РН в определённые моменты полёта, м/с
double ddv = 0;

double v = 0;                       // Переменная для расчёта необходимой скорости в определённые моменты полёта, м/с
double vx = 0;                      // Проекция этой скорости на ось Х, м/с
double vy = 0;                      // Проекция этой скорости на ось Y, м/с     

double k = 1 / (2 * Earth.R);       // Коэффициент масштаба, 1/м

int nMouseX, nMouseY;               // Координаты мыши в окне, пиксель
int pMouseX, pMouseY;               // Координаты мыши в окне в момент нажатия правой кнопки мыши, пиксель
bool pushMouse = false;             // Факт нажатия правой кнопки мыши

double XX = 0, YY = 0;              // Коордлинаты положения "Наблюдателя", м
double XObj = Earth.C[0];           // Сдвиг координаты X на выбранный объект отслеживания, м
double YObj = Earth.C[1];           // Сдвиг координаты Y на выбранный объект отслеживания, м

int obj = 3;                        // Переменная для отслеживания объектов (значение "3" соответствует Земле)

double Z[] = { 0, 1 };              // Вектор направления главной нормали (это вертикаль относительно окна)

#pragma endregion 

#pragma region Прототипы функций

double norm(double x, double y);                                        // Функция нормализации вектора
double clamp(double value, double min, double max);                     // Функция определения нахождения переменной в границах

void calc(double g[10], double phi[10], double A[2], double V[2], double C[2], int number);     // Функция расчёта одного объекта 
void calcYa(double g[10], double phi[10], double A[2], double V[2], double C[2], int number);   // Функция расчёт ядерного РН
void display();                                                                                 // Функция отрисовки
void draw();                                                                                    // Функция задания параметров графической библиотеке
void changeSize(int w, int h);                                                                  // Функиця изменения размеров окна

double calcG(double C[2], double c[2], double M);                       // Функция расчёта ускорения свободного падения
void calcGAll(double g[11], double C[2], int number);                   // Функция расчёта ускорений свободного падения всех объектов
double calcPhi(double C[2], double c[2]);                               // Функция расчёта угла
void calcPhiAll(double phi[11], double C[2], int number);               // Функция расчёта всех углов расположения объектов
void accelObj(double A[2], double g[11], double phi[11], int number);   // Функция расчёта полных ускорений объектов

void engine();                                                          // Функция расчёта тяги двигателей РН
void engineYa();
void stOut();                                                           // Функция сброса отработанных ступеней РН
void accelEng();                                                        // Функция расчёта полного ускорения РН от двигателей
void accelEngYa();

void veloc(double V[2], double A[2]);                                   // Функция расчёта скоростей объектов
void coord(double C[2], double V[2]);                                   // Функция расчёта координат объектов

void circle(double C[2], double R, double k);                           // Функция отрисовки круга
void follow();                                                          // Функция отслеживания объектов
void mouse(int button, int status, int x, int y);                       // Функция обработчика событий мыши
void mouseMove(int x, int y);                                           // Функция передвижения "Наблюдателя" в пространстве
void key(unsigned char k, int x, int y);                                // Функция обработчика клавиатуры
void timer(int i);                                                      // Функция постоянной отрисовки

#pragma endregion

int main(int argc, char** argv) {

    setlocale(LC_ALL, "Russian");   // Возможность использования русского языка в консоли

    std::cout << "Введите номер желаемой орбиты:\n1 - Химический двигатель\n2 - Импульсный ядерный ракетный двигатель гоман\n3 - Импульсный ядерный ракетный двигатель прямой\n" << std::endl;
    std::cin >> orb;

    glutInit(&argc, argv);  // Инициализаци графической библиотеки

    std::thread thrLuna(calc, Luna.g, Luna.phi, Luna.A, Luna.V, Luna.C, 9);                     // Инициализация потока-расчётчика Луны
    std::thread thrMercury(calc, Mercury.g, Mercury.phi, Mercury.A, Mercury.V, Mercury.C, 1);   // Инициализация потока-расчётчика Меркурия
    std::thread thrVenus(calc, Venus.g, Venus.phi, Venus.A, Venus.V, Venus.C, 2);               // Инициализация потока-расчётчика Венеры
    std::thread thrEarth(calc, Earth.g, Earth.phi, Earth.A, Earth.V, Earth.C, 3);               // Инициализация потока-расчётчика Земли
    std::thread thrMars(calc, Mars.g, Mars.phi, Mars.A, Mars.V, Mars.C, 4);                     // Инициализация потока-расчётчика Марса
    std::thread thrJupiter(calc, Jupiter.g, Jupiter.phi, Jupiter.A, Jupiter.V, Jupiter.C, 5);   // Инициализация потока-расчётчика Юпитера
    std::thread thrSaturn(calc, Saturn.g, Saturn.phi, Saturn.A, Saturn.V, Saturn.C, 6);         // Инициализация потока-расчётчика Сатурна
    std::thread thrUran(calc, Uran.g, Uran.phi, Uran.A, Uran.V, Uran.C, 7);                     // Инициализация потока-расчётчика Урана
    std::thread thrNeptune(calc, Neptune.g, Neptune.phi, Neptune.A, Neptune.V, Neptune.C, 8);   // Инициализация потока-расчётчика Нептуна
    std::thread thrDraw(draw);                                                                  // Инициализация потока-отрисовки

    if (orb == 1)
    {
        std::thread thrRocket(calc, Rocket.g, Rocket.phi, Rocket.A, Rocket.V, Rocket.C, 10);    // Инициализация потока-расчётчика химического РН
        thrRocket.join();   // Старт потока-расчётчика РН
    }
    else
    {
        std::thread thrRocket(calcYa, RocketYa.g, RocketYa.phi, RocketYa.A, RocketYa.V, RocketYa.C, 10);  // Инициализация потока-расчётчика ядерного РН
        thrRocket.join();   // Старт потока-расчётчика РН
    }
    thrLuna.join();         // Старт потока-расчётчика Луны
    thrMercury.join();      // Старт потока-расчётчика Меркурия
    thrVenus.join();        // Старт потока-расчётчика Венеры
    thrEarth.join();        // Старт потока-расчётчика Земли
    thrMars.join();         // Старт потока-расчётчика Марса
    thrJupiter.join();      // Старт потока-расчётчика Юпитера
    thrSaturn.join();       // Старт потока-расчётчика Сатурна
    thrUran.join();         // Старт потока-расчётчика Урана
    thrNeptune.join();      // Старт потока-расчётчика Нептуна
    thrDraw.join();         // Старт потока-отрисовки

    return 0;
}

#pragma region Функции
                                                                                // Функция нормализации вектора
double norm(double x, double y) {
    return sqrt(pow(x, 2) + pow(y, 2));     // Это теорема Пифагора
}
                                                                                // Функция определения нахождения переменной в границах
double clamp(double value, double min, double max) {
    return fmax(fmin(value, max), min);     // Возвращает значение, либо введённые min или max, если значение соответственно ниже или выше их пределов
}

                                                                                // Функция расчёта одного объекта                                                                                            
void calc(double g[10], double phi[10], double A[2], double V[2], double C[2], int number) {
    while (1) {                             // Бесконечный цикл для потоков
        if (dt > 0) {                       // Если время остановлено, приостановить расчёты

            // Этот момент потоки должны проходить только вместе, не по одному
            // Так нужно для того, чтобы пока какой-либо поток считает координаты своего объекта,
            // другие не начали на основе неполных данных считать остальные значения 
            bar1.arrive_and_wait();         // Понижение значения барьера на 1 и ожидание его освобождения

            calcGAll(g, C, number);         // Вызов функции расчёта ускорений свободного падения всех объектов
            calcPhiAll(phi, C, number);     // Вызов функции расчёта всех углов расположения объектов
            accelObj(A, g, phi, number);    // Вызов функции расчёта полного ускорения объектов

            if (number == 10) {             // Следующие три функции актуальны только для РН
                follow();
                engine();                   // Вызов функции расчёта тяги двигателей РН
                stOut();                    // Вызов функции сброса отработанных ступеней РН
                accelEng();                 // Вызов функции расчёта полного ускорения РН от двигателей
                T += dt;                    // Повышение времени на шаг, с
            }
            // Этот момент потоки должны проходить только вместе, не по одному
            bar2.arrive_and_wait();         // Понижение значения барьера на 1 и ожидание его освобождения
            // Причина аналогично предыдущему барьеру (они работают вместе)

            veloc(V, A);                    // Вызов функции расчёта скоростей объектов
            coord(C, V);                    // Вызов функции расчёта координат объектов
        }
        else {
            std::cout << "";
        }
    }
}

                                                                                // Функция расчёта ядерного РН/*********************************************************************************/                                                                                          
void calcYa(double g[10], double phi[10], double A[2], double V[2], double C[2], int number) {
    while (1) {                             // Бесконечный цикл для потоков
        if (dt > 0) {                       // Если время остановлено, приостановить расчёты

            // Этот момент потоки должны проходить только вместе, не по одному
            // Так нужно для того, чтобы пока какой-либо поток считает координаты своего объекта,
            // другие не начали на основе неполных данных считать остальные значения 
            bar1.arrive_and_wait();         // Понижение значения барьера на 1 и ожидание его освобождения

            calcGAll(g, C, number);         // Вызов функции расчёта ускорений свободного падения всех объектов
            calcPhiAll(phi, C, number);     // Вызов функции расчёта всех углов расположения объектов
            accelObj(A, g, phi, number);    // Вызов функции расчёта полного ускорения объектов

            if (number == 10) {             // Следующие три функции актуальны только для РН
                follow();
                accelEngYa();               // Вызов функции расчёта полного ускорения РН от двигателей
                engineYa();                 // Вызов функции расчёта тяги двигателей РН
                T += dt;                    // Повышение времени на шаг, с
            }
            // Этот момент потоки должны проходить только вместе, не по одному
            bar2.arrive_and_wait();         // Понижение значения барьера на 1 и ожидание его освобождения
            // Причина аналогично предыдущему барьеру (они работают вместе)

            veloc(V, A);                    // Вызов функции расчёта скоростей объектов
            coord(C, V);                    // Вызов функции расчёта координат объектов
        }
        else {
            std::cout << "";
        }
    }
}

                                                                                // Функция отрисовки
void display() {

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);                 // Задание параметров буферу отрисовки

#pragma region Отрисовка реальных размеров

    glColor3f(1.0f, 1.0f, 0.0f);        // Задание цвета Солнцу
    circle(Sun.C, Sun.R, k);            // Вызов функции для отрисовки Солнца

    glColor3f(1.0f, 1.0f, 1.0f);        // Задание цвета Луне
    circle(Luna.C, Luna.R, k);          // Вызов функции для отрисовки Луны

    glColor3f(0.7f, 0.5f, 0.0f);        // Задание цвета Меркурию
    circle(Mercury.C, Mercury.R, k);    // Вызов функции для отрисовки Меркурия

    glColor3f(1.0f, 0.7f, 0.0f);        // Задание цвета Венере
    circle(Venus.C, Venus.R, k);        // Вызов функции для отрисовки Венеры

    glColor3f(0.0f, 0.5f, 1.0f);        // Задание цвета Земле
    circle(Earth.C, Earth.R, k);        // Вызов функции для отрисовки Земли

    glColor3f(1.0f, 0.0f, 0.0f);        // Задание цвета Марсу
    circle(Mars.C, Mars.R, k);          // Вызов функции для отрисовки Марса

    glColor3f(1.0f, 1.0f, 1.0f);        // Задание цвета Юпитеру
    circle(Jupiter.C, Jupiter.R, k);    // Вызов функции для отрисовки Юпитера

    glColor3f(1.0f, 1.0f, 1.0f);        // Задание цвета Сатурну
    circle(Saturn.C, Saturn.R, k);      // Вызов функции для отрисовки Сатурна

    glColor3f(0.0f, 0.5f, 1.0f);        // Задание цвета Урану
    circle(Uran.C, Uran.R, k);          // Вызов функции для отрисовки Урана

    glColor3f(0.0f, 0.0f, 1.0f);        // Задание цвета Нетуну
    circle(Neptune.C, Neptune.R, k);    // Вызов функции для отрисовки Нептуна 

#pragma endregion

    // Закомментировать предыдущие функции отрисовки и раскомментировать эти, если необходимо отрисовывать объекты постоянного размера
#pragma region Отрисовка постоянных размеров
/*

    glColor3f(1.0f, 1.0f, 0.0f);        // Задание цвета Солнцу
    circle(Sun.C, 0.01 / k, k);         // Вызов функции для отрисовки Солнца постоянного размера

    glColor3f(1.0f, 1.0f, 1.0f);        // Задание цвета Луне
    circle(Luna.C, 0.01 / k, k);        // Вызов функции для отрисовки Луны постоянного размера

    glColor3f(0.7f, 0.5f, 0.0f);        // Задание цвета Меркурию
    circle(Mercury.C, 0.01 / k, k);     // Вызов функции для отрисовки Меркурия постоянного размера

    glColor3f(1.0f, 0.7f, 0.0f);        // Задание цвета Венере
    circle(Venus.C, 0.01 / k, k);       // Вызов функции для отрисовки Венеры постоянного размера

    glColor3f(0.0f, 0.5f, 1.0f);        // Задание цвета Земле
    circle(Earth.C, 0.01 / k, k);       // Вызов функции для отрисовки Земли постоянного размера

    glColor3f(1.0f, 0.0f, 0.0f);        // Задание цвета Марсу
    circle(Mars.C, 0.01 / k, k);        // Вызов функции для отрисовки Марса постоянного размера

    glColor3f(1.0f, 1.0f, 1.0f);        // Задание цвета Юпитеру
    circle(Jupiter.C, 0.01 / k, k);     // Вызов функции для отрисовки Юпитера постоянного размера

    glColor3f(1.0f, 1.0f, 1.0f);        // Задание цвета Сатурну
    circle(Saturn.C, 0.01 / k, k);      // Вызов функции для отрисовки Сатурна постоянного размера

    glColor3f(0.0f, 0.5f, 1.0f);        // Задание цвета Урану
    circle(Uran.C, 0.01 / k, k);        // Вызов функции для отрисовки Урана постоянного размера

    glColor3f(0.0f, 0.0f, 1.0f);        // Задание цвета Нетуну
    circle(Neptune.C, 0.01 / k, k);     // Вызов функции для отрисовки Нептуна постоянного размера
    */
#pragma endregion


    glColor3f(1.0f, 1.0f, 0.0f);                                                    // Задание цвета РН
    glBegin(GL_TRIANGLES);                                                          // РН будет представлять из себя треугольник постоянного размера

    // Домножение на sin и cos осуществляет отображение поворота РН
    if (orb == 1)
    {
        glVertex2d(                                                                     // Задание первой координаты треугольника
            -XObj * k + XX / width * 2 + Rocket.C[0] * k + 0.01 * cos(alpha),
            -YObj * k + YY / height * 2 + Rocket.C[1] * k - 0.01 * sin(alpha)
        );
        glVertex2f(                                                                     // Задание второй координаты треугольника
            -XObj * k + XX / width * 2 + Rocket.C[0] * k + 0.03 * sin(alpha),
            -YObj * k + YY / height * 2 + Rocket.C[1] * k + 0.03 * cos(alpha)
        );
        glVertex2d(                                                                     // Задание третьей координаты треугольника
            -XObj * k + XX / width * 2 + Rocket.C[0] * k - 0.01 * cos(alpha),
            -YObj * k + YY / height * 2 + Rocket.C[1] * k + 0.01 * sin(alpha)
        );
    }
    else
    {
        glVertex2d(                                                                     // Задание первой координаты треугольника
            -XObj * k + XX / width * 2 + RocketYa.C[0] * k + 0.01 * cos(alpha),
            -YObj * k + YY / height * 2 + RocketYa.C[1] * k - 0.01 * sin(alpha)
        );
        glVertex2f(                                                                     // Задание второй координаты треугольника
            -XObj * k + XX / width * 2 + RocketYa.C[0] * k + 0.03 * sin(alpha),
            -YObj * k + YY / height * 2 + RocketYa.C[1] * k + 0.03 * cos(alpha)
        );
        glVertex2d(                                                                     // Задание третьей координаты треугольника
            -XObj * k + XX / width * 2 + RocketYa.C[0] * k - 0.01 * cos(alpha),
            -YObj * k + YY / height * 2 + RocketYa.C[1] * k + 0.01 * sin(alpha)
        );
    }
    glEnd();

    glutSwapBuffers();                // Отрисовка буфера
}
                                                                                // Функция задания параметров графической библиотеке
void draw() {
    glutInitDisplayMode(GLUT_DOUBLE);   // Определение параметров окна отрисовки
    glutInitWindowSize(height, width);  // Задание размеров окна (ВхШ), пиксель
    glutInitWindowPosition(200, 200);   // Задание положения окна от левого верхнего угла экрана (ШхВ), пиксель

    glutCreateWindow("Luna");           // Задание названия окна

    glClearColor(0, 0, 0, 0);           // Задание чёрного цвета фона окна (красный, зелёный, синий, прозрачность)
    glutReshapeFunc(changeSize);        // Задание функции изменения размеров окна
    glutDisplayFunc(display);           // Задание функции отрисовки

    glutMouseFunc(mouse);               // Подключение обработчика событий иыши
    glutMotionFunc(mouseMove);          // Подключение функции движения мыши
    glutKeyboardFunc(key);              // Подключение обработчика клавиатуры
    glutTimerFunc(100, timer, 0);       // Подключение функции постоянной отрисовки

    glutMainLoop();                     // Запуск функции отрисовки
}
                                                                                // Функция изменения размеров окна
void changeSize(int w, int h) {
    if (h == 0) h = 1;              // Предупреждение деления на ноль
    float ratio = 1.0 * w / h;      // Определение отношения ширины к высоте
    glMatrixMode(GL_PROJECTION);    // Задание типа матрицы "проекция"
    glLoadIdentity();               // Обновление матрицы
    glOrtho(0, w, 0, h, 0, 0);      // Задание границ окна
}

                                                                                // Функция расчёта ускорения свободного падения
double calcG(double C[2], double c[2], double M) {
    return  G * M / pow(norm((C[0] - c[0]), (C[1] - c[1])), 2); // >> G * M / (R + h) ^ 2

}
                                                                                // Функция расчёта ускорений свободного падения всех объектов
void calcGAll(double g[11], double C[2], int number) {

    g[0] = calcG(C, Sun.C, Sun.M);          // Влияние Солнца на объект, м/с2
    g[9] = calcG(C, Luna.C, Luna.M);        // Влияние Луны на объект, м/с2
    g[1] = calcG(C, Mercury.C, Mercury.M);  // Влияние Меркурия на объект, м/с2
    g[2] = calcG(C, Venus.C, Venus.M);      // Влияние Венеры на объект, м/с2
    g[3] = calcG(C, Earth.C, Earth.M);      // Влияние Земли на объект, м/с2
    g[4] = calcG(C, Mars.C, Mars.M);        // Влияние Марса на объект, м/с2
    g[5] = calcG(C, Jupiter.C, Jupiter.M);  // Влияние Юпитера на объект, м/с2
    g[6] = calcG(C, Saturn.C, Saturn.M);    // Влияние Сатурна на объект, м/с2
    g[7] = calcG(C, Uran.C, Uran.M);        // Влияние Урана на объект, м/с2
    g[8] = calcG(C, Neptune.C, Neptune.M);  // Влияние Нептуна на объект, м/с2
    g[number] = 0;                          // Влияние объекта на самого себя (не существует)
}
                                                                                // Функция расчёта угла
double calcPhi(double C[2], double c[2]) {
    if (C[0] > c[0])                        // >> (x1 * x2 + y1 * y2)  / (sqrt(x1 ^ 2 + y1 ^ 2) * sqrt(x2 ^ 2 + y2 ^ 2)) (формула косинуса угла между векторами)
        return acos(((C[0] - c[0]) * Z[0] + (C[1] - c[1]) * Z[1]) / norm((C[0] - c[0]), (C[1] - c[1])) / norm(Z[0], Z[1]));
    else
        return -acos(((C[0] - c[0]) * Z[0] + (C[1] - c[1]) * Z[1]) / norm((C[0] - c[0]), (C[1] - c[1])) / norm(Z[0], Z[1]));
}
                                                                                // Функция расчёта всех углов расположения объектов
void calcPhiAll(double phi[11], double C[2], int number) {
    phi[0] = calcPhi(C, Sun.C);     // Угол между объектом и Солнцем
    phi[9] = calcPhi(C, Luna.C);    // Угол между объектом и Луной
    phi[1] = calcPhi(C, Mercury.C); // Угол между объектом и Меркурием
    phi[2] = calcPhi(C, Venus.C);   // Угол между объектом и Венерой
    phi[3] = calcPhi(C, Earth.C);   // Угол между объектом и Землёй
    phi[4] = calcPhi(C, Mars.C);    // Угол между объектом и Марсом
    phi[5] = calcPhi(C, Jupiter.C); // Угол между объектом и Юпитером
    phi[6] = calcPhi(C, Saturn.C);  // Угол между объектом и Сатурном
    phi[7] = calcPhi(C, Uran.C);    // Угол между объектом и Ураном
    phi[8] = calcPhi(C, Neptune.C); // Угол между объектом и Нептуном
    phi[number] = 0;                // Угол объекта относительно самого себя (не существует)

}   
                                                                                // Функция расчёта полного ускорения объектов
void accelObj(double A[2], double g[11], double phi[11], int number) {
    A[0] = 0;
    A[1] = 0;
    for (int i = 0; i < 10; i++) {      // Складываются все ускорения свободного падения, действующие на объект, кроме от него самого (тк не существует) 
        if (i == number) {}
        else {
            A[0] -= g[i] * sin(phi[i]);
            A[1] -= g[i] * cos(phi[i]);
        }
    }
}

                                                                                // Функция расчёта тяги двигателей РН
void engine() {
    if (norm((Rocket.C[0] - Earth.C[0]), (Rocket.C[1] - Earth.C[1])) - Earth.R < 100000) {                  // Пока высота полёта РН ниже 100 км (атмосфера учитывается только до этого значения высоты)

        for (int i = 0; i < 29; i++)
            if (norm((Rocket.C[0] - Earth.C[0]), (Rocket.C[1] - Earth.C[1])) - Earth.R >= Tvm[0][i]) {      // Определение значения температуры на текущей высоте полёта РН, К
                varTvm = Tvm[1][i];
                break;
            }

        Pv = Pvm * pow(e, (-Mv * Rocket.g[3] * (norm((Rocket.C[0] - Earth.C[0]), (Rocket.C[1] - Earth.C[1])) - Earth.R) / (R * varTvm)));   // Определение значения давления воздуха на текущей высоте полёта РН, Па >> exp(-Mv * g * H / (R * T))
        rv = Pv * Mv / (R * varTvm);                                                                                                        // Определение значения плотности воздуха на текущей высоте полёта РН, кг/м3

        Ts = Tpp - (Tpp - Tmm) * rv / rvm;          // Определение значения тяги двигателей РН, кН
        Is = Ipp - (Ipp - Imm) * rv / rvm;          // Опредедение значения удельной тяги двигателей РН, м/с
    }
    else {
        Ts = Tpp;                                   // Если высота полёта РН выше 100 км, то эффективные характеристики двигателей принимаются равными характеристикам в пустоте
        Is = Ipp;
    }
    if (dvig) {
        Ad = Ts / Rocket.M * 1000;                  // Определение значения ускорения РН от двигателей, м/с2

        Rocket.M -= Ts / Is * 1000 * dt;            // Учёт массового расхода топлива в единицу времени, кг/с
        Mtt -= Ts / Is * 1000 * dt;
    }
    else Ad = 0;                                    // Если двигатели выключены, то нет ускорения от них и расхода топлива
}
                                                                                // Функция расчёта тяги двигателей ядерного РН
void engineYa() {
    if (dvig && Kzar > 0) {
        if (T - Start_time >= 1.0)
        {
            Start_time = T;
            Kzar--;                                     // Выброс заряда
            RocketYa.M -= Mzar;                         // Учёт массового расхода топлива в единицу времени, кг/с
            Vd = sqrt(EWol * 2 / RocketYa.M);           // Определение значения ускорения РН от двигателей, м/с2
            RocketYa.V[0] += Vd * sin(alpha);           // Вклад двигателей в проекцию ускорения РН на ось Х
            RocketYa.V[1] += Vd * cos(alpha);           // Вклад двигателей в проекцию ускорения РН на ось Y
            ddv += Vd;
            std::cout << T << " " << Kzar << " " << ddv << "\n";
        }
    }
    else Vd = 0;                                    // Если двигатели выключены, то нет ускорения от них и расхода топлива
}
                                                                                // Функция сброса отработанных ступеней РН
void stOut() {
    if (Mtt <= 0) {
        switch (s) {                                // При отработки ступени, новые характеристики двигателей РН принимаются равными следующей ступени
        case 0:                                     // Отработала первая ступень
            Mtt = Two.Mt;
            Tpp = Two.Tp;
            Tmm = Two.Tm;
            Ipp = Two.Ip;
            Imm = Two.Im;
            Rocket.M = Two.M + Three.M + Rb.M + A.M;
            break;
        case 1:                                     // Отработала вторая ступень
            Mtt = Three.Mt;
            Tpp = Three.Tp;
            Tmm = Three.Tm;
            Ipp = Three.Ip;
            Imm = Three.Im;
            Rocket.M = Three.M + Rb.M + A.M;
            break;
        case 2:                                     // Отработала третья ступень
            Mtt = Rb.Mt;
            Tpp = Rb.Tp;
            Tmm = Rb.Tm;
            Ipp = Rb.Ip;
            Imm = Rb.Im;
            Rocket.M = Rb.M + A.M;
            break;
        case 3:                                     // Отработал разгонный блок
            Mtt = A.Mt;
            Tpp = A.Tp;
            Tmm = A.Tm;
            Ipp = A.Ip;
            Imm = A.Im;
            Rocket.M = A.M;
            break;
        case 4:                                     // Отработал аппарат
            Mtt = 1;
            Tpp = 0;
            Tmm = 0;
            Ipp = 0;
            Imm = 0;
            Rocket.M = A.Ms;
            dvig = 0;
            break;
        }
        s++;                                        // Повышается счётчик отработанных ступеней
    }
}                                                                 // Функция расчёта полных ускорений объектов
                                                                                // Функция расчёта полного ускорения РН от двигателей
void accelEng() {

    ddv += Ad * dt;
    /*....................Вертикальный взлёт....................*/
    if (norm((Rocket.C[0] - Earth.C[0]), (Rocket.C[1] - Earth.C[1])) - Earth.R < 20000)                                                         // Первые 20 км полёта РН летит вертикально, пока не пройдёт плотные слои атмосферы
        alpha = Rocket.phi[3];
    else if (T < 1200) {                                                                                                                        // Это и последующие ограничения на время заданы для того, чтобы программа в эту часть кода больше не возвращалась
        /*....................Отклонение для выхода на орбиту....................*/
        if (norm((Rocket.C[0] - Earth.C[0]), (Rocket.C[1] - Earth.C[1])) - Earth.R < 160000) {
            alpha = PI / 2 * (norm((Rocket.C[0] - Earth.C[0]), (Rocket.C[1] - Earth.C[1])) - Earth.R) / 215000;                                 // После 20 км РН начинает отклонять вектор двигателя для выхода на орбиту 180 км
            alpha = Rocket.phi[3] + clamp(alpha, 0, PI / 2);
        }
        else {
            /*....................Выход на орбиту 180 км....................*/
            v = sqrt(G * Earth.M / norm((Rocket.C[0] - Earth.C[0]), (Rocket.C[1] - Earth.C[1])));                                               // Когда высота полёта РН выше 180 км определяется скорость, которая необходима для выхода на круговую орбиту текущей высоты >> sqrt(G * M / (R + h))
            vx = v * cos(Rocket.phi[3]);                                                                                                        // Определёются составляющие этой скорости в проекциях на оси X и Y, м/с
            vy = v * sin(Rocket.phi[3]);
            alpha = PI / 2 + acos((vx - Rocket.V[0] + Earth.V[0]) / norm((vx - Rocket.V[0] + Earth.V[0]), (vy + Rocket.V[1] + Earth.V[1])));    // Определяется такой угол направления вектора тяги РН, чтобы недостающие импульсы по осям достигли необходимого значения одновременно, рад
            if (s < 3 && norm((Rocket.C[0] - Earth.C[0]), (Rocket.C[1] - Earth.C[1])) - Earth.R < 200000)
                alpha = clamp(alpha, 0, 0.99 * PI + (Rocket.phi[3] - acos(-norm(Rocket.A[0], Rocket.A[1]) / Ad)));                              // Ограничение на максимальный угол задаётся таким, чтобы проекция ускорения от двигателей компенсировала притяжение Земли (домножение на 0.99 - корректировка для правильного выхода на орбиту)
            if (norm(Rocket.V[0] - Earth.V[0], Rocket.V[1] - Earth.V[1]) >= v - 5) {  // "-5" - очередная корректировка, чтобы не переборщить с импульсом и достичь максимально круглой орбиты
                dvig = 0;                                                                                                                       // Если достигнута необходимая скорость, двигатели выключаются
            }
        }
    }
    /*....................Движение по орбите Земли....................*/
    else {
        if (T < 5000)                                                                                                                           // Время 5000 с взято с потолка, чтобы к этому моменту РН точно отлетела от Земли, с
            if (Rocket.C[1] >= Earth.C[1])
                alpha = acos((Rocket.V[1] - Earth.V[1]) / norm((Rocket.V[0] - Earth.V[0]), (Rocket.V[1] - Earth.V[1])));                        // Угол аналогичен предыдущей установке, рад
            else
                alpha = -acos((Rocket.V[1] - Earth.V[1]) / norm((Rocket.V[0] - Earth.V[0]), (Rocket.V[1] - Earth.V[1])));

        /*....................ХИМИЧЕСКИЙ ДВИГАТЕЛЬ....................*/

        if (orb == 1) {
            /*....................Импульс для перелёта к Луне....................*/
            if (T >= 3482 && T < 235000) {                                                                                                          // 3482 - время запуска двигателей, с
                if (T >= 5000)
                    if (Rocket.V[1] >= Luna.V[1])                                                                                                   // После отлёта РН от Земли
                        alpha = acos((Rocket.V[1] - Luna.V[1]) / norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])));                       // Угол РН такой, что она смотрит по направлению своего движения относительно Луны, рад
                    else
                        alpha = -acos((Rocket.V[1] - Luna.V[1]) / norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])));
                if ((int)T == 3482) {                                                                                                               // Момент времени, в который необходимо включить двигатели РН (подобран опытным путём), с
                    dvig = 1;
                    Vg = norm((Rocket.V[0] - Earth.V[0]), (Rocket.V[1] - Earth.V[1]))                                                               // Крайне длинная формула, поэтому строки переносятся >> V * (sqrt(2 * k / (k + 1)) - 1)
                        * (sqrt(2 * ((norm((Earth.C[0] - Luna.C[0]), (Earth.C[1] - Luna.C[1])) + Luna.R + pow(10, 5)) / (norm((Rocket.C[0] - Earth.C[0]), (Rocket.C[1] - Earth.C[1]))))     // k = необходимая высота орбиты / текущая высота орбиты 
                            / (((norm((Earth.C[0] - Luna.C[0]), (Earth.C[1] - Luna.C[1])) + Luna.R + pow(10, 5)) / (norm((Rocket.C[0] - Earth.C[0]), (Rocket.C[1] - Earth.C[1])))) + 1)) - 1);  // Определяется первый гомановский импульс, для перелёта к Луне, м/с
                }
                dV += Ad * dt;
                if (dV >= Vg * 1.015) {                                                                                                             // Когда достигнут необходимый импульс, двигатели выключаются, а переменная dV обнуляется для расчётов последующих импульсов
                    dvig = 0;                                                                                                                       // 1.015 - поправочный коэффициент, учитывающий не мгновенную передачу импульса
                    dV = 0;
                }
            }
            /*....................Перелёт к Луне (~3 дня)....................*/
            /*....................Корректировака на подлёте к Луне....................*/
            else if (T >= 235000 && T < 236900) {
                if (T <= 235900) {
                    if (Rocket.V[1] >= Luna.V[1])
                        alpha = PI + acos((Rocket.V[1] - Luna.V[1]) / norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])));                  // Угол РН такой, что она смотрит против направления своего движения относительно Луны, рад
                    else
                        alpha = PI - acos((Rocket.V[1] - Luna.V[1]) / norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])));
                }
                if ((int)T == 235000)
                    dvig = 1;
                dV += Ad * dt;
                if (T < 235800) {
                    if (dV >= 330) {                                                                        // Подобранная опытным путём корректировка на подлёте к Луне, чтобы РН пролетела в 100 км от поверхности, м/с
                        dvig = 0;
                        dV = 0;
                    }
                }
                /*....................Выход на орбиту Луны 100 км....................*/
                else {
                    if ((int)T == 235800) {                                                                 // В данный момент времени включить двигатели, что выйти на орбиту 100 км вокруг Луны
                        v = sqrt(G * Luna.M / Luna.R + 100000);                                             // Скорость, необходимая для выхода на орбиту 100 км вокруг Луны/
                        Vg = norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])) * 1.02 - v;         // 1.02 - поправочный коэффициент, учитывающий не мгновенную передачу импульса
                        dvig = 1;
                    }
                    vx = v * cos(Rocket.phi[9]);                                                            // Определение проекций этой скорости на оси Х и Y, м/с
                    vy = -v * sin(Rocket.phi[9]);
                    alpha = PI / 2 + acos((vx - Rocket.V[0] + Luna.V[0]) / norm((vx - Rocket.V[0] + Luna.V[0]), (vy - Rocket.V[1] + Luna.V[1])));   // Определяется такой угол направления вектора тяги РН, чтобы недостающие импульсы по осям достигли необходимого значения одновременно, рад
                    dV += Ad * dt;
                    if (dV >= Vg) {
                        dvig = 0;
                        dV = 0;
                        v = sqrt(G * Luna.M / norm((Rocket.C[0] - Luna.C[0]), (Rocket.C[1] - Luna.C[1])));  // Задание скорости, которая должна быть достигнута к концу импульса, м/с
                        Rocket.V[0] = v * cos(Rocket.phi[9]) + Luna.V[0];
                        Rocket.V[1] = -v * sin(Rocket.phi[9]) + Luna.V[1];
                    }
                }
            }
            /*....................Снижение до 18 км....................*/
            else if (T >= 236900) {
                if (Rocket.C[1] >= Luna.C[1])
                    alpha = PI + acos((Rocket.V[1] - Luna.V[1]) / norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])));  // Угол РН такой, что она смотрит против направления своего движения относительно Луны, рад
                else
                    alpha = PI - acos((Rocket.V[1] - Luna.V[1]) / norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])));
                if ((int)T == 236900) {
                    Vg = norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1]))                                             // Определение импульса, необходимого для снижения перигелия орбиты до 18 км, м/с
                        * (sqrt(2 * (Luna.R + 18000) / (norm((Rocket.C[0] - Luna.C[0]), (Rocket.C[1] - Luna.C[1])))
                            / (((Luna.R + 18000) / (norm((Rocket.C[0] - Luna.C[0]), (Rocket.C[1] - Luna.C[1])))) + 1)) - 1);
                    dvig = 1;
                }
                dV += Ad * dt;
                if (dV >= abs(Vg) * 1.003 && T < 240300) {// 1.003 - поправочный коэффициент, учитывающий не мгновенную передачу импульса
                    dvig = 0;
                    dV = 0;
                }
                /*....................Посадка....................*/
                if (T >= 240500) {
                    if ((int)T == 240500) {
                        dvig = 1;
                        ddv = 0;
                    }
                    if ((Rocket.V[0] - Luna.V[0]) * cos(Rocket.phi[9]) + (Rocket.V[1] - Luna.V[1]) * sin(Rocket.phi[9]) >= 1
                        && norm((Rocket.C[0] - Luna.C[0]), (Rocket.C[1] - Luna.C[1])) - Luna.R >= 5600)                         // Увеличение тяги двигателей для усиления замедления РН
                        Ad *= 5;
                    else if (norm((Rocket.C[0] - Luna.C[0]), (Rocket.C[1] - Luna.C[1])) - Luna.R >= 5600)                       // Если горизонтальная скорость РН, относительно поверхности Луны, меньше 1 м/с, двигатели отключаются
                        dvig = 0;
                    if (norm((Rocket.C[0] - Luna.C[0]), (Rocket.C[1] - Luna.C[1])) - Luna.R <= 5600) {                          // На высоте 5600 м включаются двигатели РН для торможения (подобрано опытным путём)
                        if (abs((Rocket.V[0] - Luna.V[0]) * sin(Rocket.phi[9]) + (Rocket.V[1] - Luna.V[1]) * cos(Rocket.phi[9])) >= 2) { // Вертикальная скорость поддерживается до 2 м/с тягой двигателей
                            dvig = 1;
                        }
                        else
                            dvig = 0;
                    }
                    if (norm((Rocket.C[0] - Luna.C[0]), (Rocket.C[1] - Luna.C[1])) - Luna.R <= 0) {                              // Если РН села на Луну, симуляция останавливается
                        dt = 0;
                    }
                }
            }
        }

        /*....................ИМПУЛЬСНЫЙ ЯДЕРНЫЙ РАКЕТНЫЙ ДВИГАТЕЛЬ....................*/

        else if (orb == 2) {
            /*....................Импульс для перелёта к Луне....................*/
            if (T >= 3515 && T < 244000) {                                                                                          // 3515 - время запуска двигателей, с
                if (T >= 5000)
                    if (Rocket.C[1] >= Luna.C[1])                                                                                   // После отлёта РН от Земли
                        alpha = -acos((Rocket.V[1] - Luna.V[1]) / norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])));      // Угол РН такой, что она смотрит по направлению своего движения относительно Луны, рад
                    else
                        alpha = acos((Rocket.V[1] - Luna.V[1]) / norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])));
                if ((int)T == 3515) {                                                                                               // Момент времени, в который необходимо включить двигатели РН (подобран опытным путём), с
                    dvig = 1;
                    Vg = norm((Rocket.V[0] - Earth.V[0]), (Rocket.V[1] - Earth.V[1]))                                               // Крайне длинная формула, поэтому строки переносятся >> V * (sqrt(2 * k / (k + 1)) - 1)
                        * (sqrt(2 * ((norm((Earth.C[0] - Luna.C[0]), (Earth.C[1] - Luna.C[1])) + Luna.R + pow(10, 5)) / (norm((Rocket.C[0] - Earth.C[0]), (Rocket.C[1] - Earth.C[1]))))         // k = необходимая высота орбиты / текущая высота орбиты 
                            / (((norm((Earth.C[0] - Luna.C[0]), (Earth.C[1] - Luna.C[1])) + Luna.R + pow(10, 5)) / (norm((Rocket.C[0] - Earth.C[0]), (Rocket.C[1] - Earth.C[1])))) + 1)) - 1);  // Определяется первый гомановский импульс, для перелёта к Луне, м/с
                }
                dV += Ad * dt;
                if (dV >= Vg * 1.015) {                                                                                             // Когда достигнут необходимый импульс, двигатели выключаются, а переменная dV обнуляется для расчётов последующих импульсов
                    dvig = 0;                                                                                                       // 1.015 - поправочный коэффициент, учитывающий не мгновенную передачу импульса
                    dV = 0;
                }
            }
            /*....................Перелёт к Луне ~3 дня....................*/
            /*....................Корректировка на подлёте к Луне....................*/
            else if (T >= 244000 && T <= 244800) {
                if (Rocket.C[1] >= Luna.C[1])
                    alpha = PI - acos((Rocket.V[1] - Luna.V[1]) / norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])));      // Угол РН такой, что она смотрит против направления своего движения относительно Луны, рад
                else
                    alpha = PI + acos((Rocket.V[1] - Luna.V[1]) / norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])));
                if ((int)T == 244000)
                    dvig = 1;
                dV += Ad * dt;
                if (dV >= 275) {                                                                                                    // Подобранная опытным путём корректировка на подлёте к Луне, чтобы РН пролетела в 100 км от поверхности, м/с
                    dvig = 0;
                    dV = 0;
                }
            }
            /*....................Выход на орбиту Луны 100 км....................*/
            else  if (T >= 244800) {
                if (Rocket.C[1] >= Luna.C[1])
                    alpha = PI - acos((Rocket.V[1] - Luna.V[1]) / norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])));      // Угол аналогичен последней установке, рад
                else
                    alpha = PI + acos((Rocket.V[1] - Luna.V[1]) / norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])));
                if ((int)T == 245000) {
                    v = sqrt(G * Luna.M / (Luna.R + 100000));                                           // Скорость, необходимая для выхода на орбиту 100 км вокруг Луны
                    Vg = norm((Rocket.V[0] - Luna.V[0]), (Rocket.V[1] - Luna.V[1])) - v;
                    dvig = 1;
                }
                vx = -v * cos(Rocket.phi[9]);
                vy = v * sin(Rocket.phi[9]);
                alpha = acos((vy - Rocket.V[1] + Luna.V[1]) / norm((vx - Rocket.V[0] + Luna.V[0]), (vy - Rocket.V[1] + Luna.V[1])));
                dV += Ad * dt;
                if (dV >= Vg) {
                    dvig = 0;
                    dV = 0;
                    v = sqrt(G * Luna.M / norm((Rocket.C[0] - Luna.C[0]), (Rocket.C[1] - Luna.C[1])));  // Задание скорости, которая должна быть достигнута к концу импульса, м/с
                    Rocket.V[0] = -v * cos(Rocket.phi[9]) + Luna.V[0];
                    Rocket.V[1] = v * sin(Rocket.phi[9]) + Luna.V[1];
                }
            }
        }
    }
    Rocket.A[0] += Ad * sin(alpha);             // Вклад двигателей в проекцию ускорения РН на ось Х
    Rocket.A[1] += Ad * cos(alpha);             // Вклад двигателей в проекцию ускорения РН на ось Y
}
                                                                                // Функция расчёта полного ускорения РН от двигателей ЯРД**********************************************************************
void accelEngYa() {
    if (orb == 2)
    {
        /*....................Вертикальный взлёт....................*/
        if (norm((RocketYa.C[0] - Earth.C[0]), (RocketYa.C[1] - Earth.C[1])) - Earth.R < 0)                                                     // Первые 20 км полёта РН летит вертикально, пока не пройдёт плотные слои атмосферы
            alpha = RocketYa.phi[3];
        else if (T < 160) {                                                                                                                        // Это и последующие ограничения на время заданы для того, чтобы программа в эту часть кода больше не возвращалась
            /*....................Отклонение для выхода на орбиту....................*/
            if (norm((RocketYa.C[0] - Earth.C[0]), (RocketYa.C[1] - Earth.C[1])) - Earth.R < 160000) {
                alpha = PI / 2 * (norm((RocketYa.C[0] - Earth.C[0]), (RocketYa.C[1] - Earth.C[1])) - Earth.R) / 150000;                                 // После 20 км РН начинает отклонять вектор двигателя для выхода на орбиту 280 км
                alpha = RocketYa.phi[3] + clamp(alpha, 0, PI / 2);
            }
            else {
                /*....................Выход на орбиту 280 км....................*/
                v = sqrt(G * Earth.M / norm((RocketYa.C[0] - Earth.C[0]), (RocketYa.C[1] - Earth.C[1])));                                             // Когда высота полёта РН выше 280 км определяется скорость, которая необходима для выхода на круговую орбиту текущей высоты >> sqrt(G * M / (R + h))
                vx = v * cos(RocketYa.phi[3]);                                                                                                        // Определёются составляющие этой скорости в проекциях на оси X и Y, м/с
                vy = v * sin(RocketYa.phi[3]);
                alpha = PI / 2 + acos((vx - RocketYa.V[0] + Earth.V[0]) / norm((vx - RocketYa.V[0] + Earth.V[0]), (vy + RocketYa.V[1] + Earth.V[1])));    // Определяется такой угол направления вектора тяги РН, чтобы недостающие импульсы по осям достигли необходимого значения одновременно, рад
                if (norm((RocketYa.C[0] - Earth.C[0]), (RocketYa.C[1] - Earth.C[1])) - Earth.R < 200000)
                    alpha = clamp(alpha, 0, 0.99 * PI + (RocketYa.phi[3] - acos(-norm(RocketYa.A[0], RocketYa.A[1]) / Ad)));                              // Ограничение на максимальный угол задаётся таким, чтобы проекция ускорения от двигателей компенсировала притяжение Земли (домножение на 0.99 - корректировка для правильного выхода на орбиту)
                if (norm(RocketYa.V[0] - Earth.V[0], RocketYa.V[1] - Earth.V[1]) >= v - 5) {  // "-5" - очередная корректировка, чтобы не переборщить с импульсом и достичь максимально круглой орбиты
                    dvig = 0;                                                                                                                       // Если достигнута необходимая скорость, двигатели выключаются
                }
            }
        }
        /*....................Движение по орбите Земли....................*/
        else {
            if (T < 5000)                                                                                                                           // Время 5000 с взято с потолка, чтобы к этому моменту РН точно отлетела от Земли, с
                if (RocketYa.C[1] >= Earth.C[1])
                    alpha = acos((RocketYa.V[1] - Earth.V[1]) / norm((RocketYa.V[0] - Earth.V[0]), (RocketYa.V[1] - Earth.V[1])));                        // Угол аналогичен предыдущей установке, рад
                else
                    alpha = -acos((RocketYa.V[1] - Earth.V[1]) / norm((RocketYa.V[0] - Earth.V[0]), (RocketYa.V[1] - Earth.V[1])));
            /*....................Импульс для перелёта к Луне....................*/
            if (T >= 3505 && T < 269500) {                                                                                          // 3515 - время запуска двигателей, с
                if (T >= 5000)
                    if (RocketYa.C[1] >= Luna.C[1])                                                                                   // После отлёта РН от Земли
                        alpha = -acos((RocketYa.V[1] - Luna.V[1]) / norm((RocketYa.V[0] - Luna.V[0]), (RocketYa.V[1] - Luna.V[1])));      // Угол РН такой, что она смотрит по направлению своего движения относительно Луны, рад
                    else
                        alpha = acos((RocketYa.V[1] - Luna.V[1]) / norm((RocketYa.V[0] - Luna.V[0]), (RocketYa.V[1] - Luna.V[1])));
                if ((int)T == 3505) {                                                                                               // Момент времени, в который необходимо включить двигатели РН (подобран опытным путём), с
                    dvig = 1;
                    Vg = norm((RocketYa.V[0] - Earth.V[0]), (RocketYa.V[1] - Earth.V[1]))                                               // Крайне длинная формула, поэтому строки переносятся >> V * (sqrt(2 * k / (k + 1)) - 1)
                        * (sqrt(2 * ((norm((Earth.C[0] - Luna.C[0]), (Earth.C[1] - Luna.C[1])) + Luna.R + pow(10, 5)) / (norm((RocketYa.C[0] - Earth.C[0]), (RocketYa.C[1] - Earth.C[1]))))         // k = необходимая высота орбиты / текущая высота орбиты 
                            / (((norm((Earth.C[0] - Luna.C[0]), (Earth.C[1] - Luna.C[1])) + Luna.R + pow(10, 5)) / (norm((RocketYa.C[0] - Earth.C[0]), (RocketYa.C[1] - Earth.C[1])))) + 1)) - 1);  // Определяется первый гомановский импульс, для перелёта к Луне, м/с
                }
                if (dvig && Kzar > 0) {
                    if (T - Start_time >= 1.0)
                    {
                        dV += Vd;
                        if (dV >= Vg - 100) {                                                                                             // Когда достигнут необходимый импульс, двигатели выключаются, а переменная dV обнуляется для расчётов последующих импульсов
                            dvig = 0;                                                                                                       // 1.015 - поправочный коэффициент, учитывающий не мгновенную передачу импульса
                            dV = 0;
                        }
                    }
                }
            }
            /*....................Перелёт к Луне ~3 дня....................*/
            /*....................Выход на орбиту Луны 100 км....................*/
            else  if (T >= 269500) {
                if (RocketYa.C[1] >= Luna.C[1])
                    alpha = PI + acos((RocketYa.V[1] - Luna.V[1]) / norm((RocketYa.V[0] - Luna.V[0]), (RocketYa.V[1] - Luna.V[1])));      // Угол аналогичен последней установке, рад
                else
                    alpha = PI - acos((RocketYa.V[1] - Luna.V[1]) / norm((RocketYa.V[0] - Luna.V[0]), (RocketYa.V[1] - Luna.V[1])));
                if ((int)T == 269500) {
                    v = sqrt(G * Luna.M / (Luna.R + 100000));                                           // Скорость, необходимая для выхода на орбиту 100 км вокруг Луны
                    Vg = norm((RocketYa.V[0] - Luna.V[0]), (RocketYa.V[1] - Luna.V[1])) - v;
                    dvig = 1;
                }
                if (dvig && Kzar > 0) {
                    if (T - Start_time >= 1.0)
                    {
                        dV += Vd;
                        if (dV >= Vg) {                                                                                             // Когда достигнут необходимый импульс, двигатели выключаются, а переменная dV обнуляется для расчётов последующих импульсов
                            dvig = 0;                                                                                                       // 1.015 - поправочный коэффициент, учитывающий не мгновенную передачу импульса
                            dV = 0;
                        }
                    }
                }
            }
        }
    }
    else
    {
        if (Kzar >= 250)
        {
            alpha = RocketYa.phi[3] + PI / 134;
        }
        else if (norm(RocketYa.C[0] - Luna.C[0], RocketYa.C[1] - Luna.C[1]) - Luna.R >= 2.0 * pow(10, 6))
        {
            dvig = 0;
            alpha = PI + RocketYa.phi[3];
        }
        if (norm(RocketYa.C[0] - Luna.C[0], RocketYa.C[1] - Luna.C[1]) - Luna.R <= 1.1 * pow(10, 6) && Kzar > 101)
        {
            dvig = 1;
        }
        if (Kzar <= 100)

        {
            if (RocketYa.C[1] >= Luna.C[1])
            {
                alpha = PI + acos((RocketYa.V[1] - Luna.V[1]) / norm((RocketYa.V[0] - Luna.V[0]), (RocketYa.V[1] - Luna.V[1])));      // Угол аналогичен последней установке, рад
            }
            else
            {
                alpha = PI - acos((RocketYa.V[1] - Luna.V[1]) / norm((RocketYa.V[0] - Luna.V[0]), (RocketYa.V[1] - Luna.V[1])));
            }
            if (Kzar == 100)
            {
                v = sqrt(G * Luna.M / (Luna.R + 150000));                                           // Скорость, необходимая для выхода на орбиту 100 км вокруг Луны
                Vg = norm((RocketYa.V[0] - Luna.V[0]), (RocketYa.V[1] - Luna.V[1])) - v;
            }
            if (dvig && Kzar > 0)
            {
                if (T - Start_time >= 1.0)
                {
                    dV += Vd;
                    if (dV >= Vg)
                    {                                                                                             // Когда достигнут необходимый импульс, двигатели выключаются, а переменная dV обнуляется для расчётов последующих импульсов
                        dvig = 0;                                                                                                       // 1.015 - поправочный коэффициент, учитывающий не мгновенную передачу импульса
                        dV = 0;
                    }
                }
            }
        }
    }
}


                                                                                // Функция расчёта скоростей объектов
void veloc(double V[2], double A[2]) {
    V[0] += A[0] * dt;    // Изменение проекции скорости объекта на координату X за единицу времени
    V[1] += A[1] * dt;    // Изменение проекции скорости объекта на координату Y за единицу времени
}
                                                                                // Функция расчёта координат объектов
void coord(double C[2], double V[2]) {
    C[0] += V[0] * dt;    // Изменение координаты Х объекта за единицу времени
    C[1] += V[1] * dt;    // Изменение координаты Y объекта за единицу времени
}
                                                                                // Функция отрисовки круга
void circle(double C[2], double R, double k) {
    glBegin(GL_TRIANGLE_FAN);
    for (int i = 0; i <= 100; i++) {    // Круг состоит из 100 треугольников (значение с потолка)
        glVertex2f(
            (-XObj * k + XX / width * 2 + C[0] * k + (R * k * cos(i * 2 * PI / 100))), (-YObj * k + YY / height * 2 + C[1] * k + (R * k * sin(i * 2 * PI / 100)))   // "XX / width * 2" и "YY / height * 2" - Движение мышью
        );                                                                                                                                                          // "X * k" и "Y * k"                    - Координаты объекта в пространстве окна
    }                                                                                                                                                               // "XObj * k" и "YObj * k"                  - Сдвиг отрисовки на выбранный объект отслеживания
    glEnd();
}
                                                                                // Функция отслеживания объектов
void follow() {
    switch (obj) {          // Дополнение к функции обработчика клавиатуры (key) для постоянного отслеживания
    case 0:                 // Необходимо, тк объекты движутся, и требуется постоянное обновление данных координат
        XObj = Sun.C[0];
        YObj = Sun.C[1];
        break;
    case 1:
        XObj = Mercury.C[0];
        YObj = Mercury.C[1];
        break;
    case 2:
        XObj = Venus.C[0];
        YObj = Venus.C[1];
        break;
    case 3:
        XObj = Earth.C[0];
        YObj = Earth.C[1];
        break;
    case 4:
        XObj = Mars.C[0];
        YObj = Mars.C[1];
        break;
    case 5:
        XObj = Jupiter.C[0];
        YObj = Jupiter.C[1];
        break;
    case 6:
        XObj = Saturn.C[0];
        YObj = Saturn.C[1];
        break;
    case 7:
        XObj = Uran.C[0];
        YObj = Uran.C[1];
        break;
    case 8:
        XObj = Neptune.C[0];
        YObj = Neptune.C[1];
        break;
    case 9:
        XObj = Luna.C[0];
        YObj = Luna.C[1];
        break;
    case -3:                // Код ASCII цифр приводится так, чтобы при нажатии на "0", отрисовывалось Солнце, его код ASCII = 48, поэтому из всех кодов вычитается 48
        XObj = Rocket.C[0]; // Код ASCII знака "=" = 45, поэтому obj = -3
        YObj = Rocket.C[1];
        break;
    }
}
                                                                                // Функция обработчика событий мыши
void mouse(int button, int status, int x, int y) {
    nMouseX = x;                                    // Запоминается текущее положения мыши
    nMouseY = y;
    if (button == 0) {
        if (status == 0) {
            pushMouse = true;
            pMouseX = nMouseX;                      // Если правая кнопка мыши нажата, фиксируетя нажатие и запоминаются её координаты
            pMouseY = nMouseY;
        }
        else pushMouse = false;                     // Если правая кнопка мыши отпущена, фиксируетя это событие
    }
    if (button == 2) {                              // Если левая кнопка мыши нажата, координаты положения "Наблюдателя" в пространстве обнуляются
        XX = 0;                                     // То есть, отслеживаемый объект перемещается в центр окна
        YY = 0;
    }
    if (button == 3)   k += 1 / (200 * Earth.R);    // Если колесо мыши крутится вперёд, масштаб отображения увеличивается (значение 200 радиусов Земли подобрано опытным путём для удобного масштабирования)
    if (button == 4)   k -= 1 / (200 * Earth.R);    // Если колесо мыши крутится назад, масштаб отображения уменьшается
    k = clamp(k, 0, 1);                             // Ограничение на масштаб, чтобы избежать отрицательных значений
}
                                                                                // Функция передвижения "Наблюдателя" в пространстве
void mouseMove(int x, int y) {
    nMouseX = x;                    // Запоминается текущее положение мыши
    nMouseY = y;
    if (pushMouse == true) {
        XX += nMouseX - pMouseX;    // Если правая кнопка мыши нажата, изменяются координаты положения "Наблюдателя" в пространстве
        pMouseX = nMouseX;
        YY -= nMouseY - pMouseY;
        pMouseY = nMouseY;
        display();                  // Отрисовка окна
    }
}
                                                                                // Функция обработчика клавиатуры
void key(unsigned char k, int x, int y) {

    /*..........Отслеживание объектов..........*/
    if ((k >= 48 && k <= 57) || k == 45) {  // При нажатии клавиш цифр, отображается объект по порядку в Солнечной системе (0 - Солнце, 1 - Меркурий и т.д.)
        obj = int(k) - 48;                  // Чтобы отобразить РН надо нажать "-"
        XX = 0;                             // Чтобы отобразить Луну надо нажать "9"
        YY = 0;                             // Координаты положения "Наблюдателя" обнуляются, чтобы объект был по центру окна
    }

    /*..........Изменение скорости времени..........*/
    if (k == 'e') {                             // Если нажата клавиша "e", время ускоряется на 1 секунду в секунду реального времени (обязательна включена английская раскладка)
        dt += 0.01;
        std::cout << "dt = " << dt << std::endl;
    }
    else if (k == 'q') {                        // Если нажата клавиша "q", время замедляется на 1 секунду в секунду реального времени
        dt -= 0.01;
        dt = clamp(dt, 0, 1000);                // Ограничение, чтобы время не текло в обратную сторону
        std::cout << "dt = " << dt << std::endl;
    }
    else if (k == ' ') {                        // Если нажата клавиша "пробел", время останавливается
        dt = 0;
        std::cout << "dt = " << dt << std::endl;
    }
}
                                                                                // Функция постоянной отрисовки
void timer(int i) {
    display();
    glutTimerFunc(10, timer, 0);  // Окно отрисовывается принудительно каждые 10 миллисекунд (100 кадров в секунду)
}

#pragma endregion
